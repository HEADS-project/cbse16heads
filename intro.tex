\section{Introduction}

Modern software-based services increasingly rely on a highly heterogeneous and dynamic interconnection of platforms and devices offering a wide diversity of capabilities. On the one end of the continuum, cloud platforms provide virtually unlimited and ”on-demand” resources in terms of computation power, storage and bandwidth. On the other end, the already vast and rapidly increasing number of smart objects, sensors, embedded systems and mobile devices connected to the Internet offers the connection to the users and to the physical world. While offering great potential for innovative services, for example in the eHealth domain, the heterogeneity, diversity and vast distribution represent daunting challenges. 

To implement such distributed services, which will be deployed on an heterogeneous infrastructure, software developers have access to a plethora of components and libraries (both open and closed source) that they can use to rapidly build up applications and services. Even though programming languages tend to become more and more versatile (for example JavaScript evolving from a client-side scripting language to a server-side programming language with Node.JS), a study of a large number of open-source projects~\cite{DBLP:conf/icse/MorinFB15} indicates that no programming language is able to stretch so that they can fully cover the whole range of platforms. C/C++ remains the de-facto language for embedded systems as it gives programmers control on every bits and bytes, while Java (Android) and JavaScript/HTML5 is the winning duo for mobile applications. For developing large-scale, distributed algorithms and systems, the abstraction providing by Java seems to prevail over the performances provided by lower-level languages like C/C++. Beside the very popular languages (Java, JavaScript, C/C++), many languages are being used in specific niches e.g. Lua is used as a scripting language in several home automation gateways or game engines. 

In any large-scale distributed system, it should be expected that several programming languages will be used to implement or reuse different components. On the one hand, the number of languages should be kept as low and as coherent as possible to keep the development team coherent and enable experts in one language to still understand expert in another language and the code they wrote, contributing to reducing the overall complexity of the system. On the other hand, the "cost" of sticking with a language that is "not right for the job" should be carefully balanced. While Java Servlets and JSP allowed Java developers to get started with Web development, the decadent popularity of those technologies (while Java itself still remains popular) indicates they were "not right for the job" e.g. all banks in Norway have moved away from those technologies and migrated their system, at a high cost. 

This paper presents a set of languages based on well-established formalisms (components with port and messages for the interfaces and state machines for the implementation)  dedicated to the integration, deployment and continuous operation of existing libraries and components already available and implemented in various languages. This approach is validated on an industrial case study in the eHealth domain and implemented by TellU. This case study involves a large number of sensors, devices and gateways based on Rasperry Pi, Intel Edison and Arduino. 

The remainder of this paper is organized as follows. Section II  motivates our work, both the particular case of an eHealth application and the associated general software engineering challenges. Section III presents our approach to tackle those challenges. In Section IV, we apply our approach on an eHealth service developed by TellU. Section V presents related work while Section VI concludes this paper and presents ongoing work. 
